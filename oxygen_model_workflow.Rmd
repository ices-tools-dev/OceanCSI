---
title: "oxygen indicator"
author: "Willem Stolte"
date: "2025-03-03"
output: html_document
params: 
  percentile: "05" # change if necessary
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table)
library(readr)
library(dplyr)
library(ggExtra)
require(leaflet)
source("utilities_plot.R")
source("utilities_bathymetric.R")
assessmentYear <- 2024
```

Improve workflow

-   read data
-   check quality
    -   are values valid?
    -   are geometries correct?
    -   are bathymetric values complete?
-   filter data based on depth, month, other?
-   assign oxygen class
-   assign period (\< 2000, \>= 2000)
-   calculate relevant percentiles
-   group_by station, date, oxygen class, period
-   apply kendall test to each group (example: <https://lemuscanovas.github.io/post/20200708/trends/>)
-   collect relevant statistics

## Introduction

```{r read-data}
# stationSamples <- fread(file.path("Data", "1980-2023_StationSamplesOxygen.csv.gz"))
load("data/stationSamples_correctedBathymetry.RData")
```

## Check bathymetry data

```{r check-bathymetry}

missingBathymetries <- length(which(is.na(stationSamples_with_new_bathymetric$Bathymetric)))
if(missingBathymetries !=0){
  cat("There are ", missingBathymetries, "number of records which do currently not have a Bathymetry associated") 
} else {
  cat("All records contain a bathymetry")
}

```

```{r}


plot <- stationSamples_with_new_bathymetric %>%
  sample_n(50000) %>%
  ggplot(aes(x=Bathymetric, y=Depth))+
  geom_point()+
  theme(legend.position="none") +
  coord_equal()

# use ggMarginal function to create marginal histogram
ggMarginal(plot, type="histogram")
```

## Invalid bathymetric values

```{r}
stationSamples_with_new_bathymetric %>%
  mutate(diffDepth = Bathymetric - Depth) %>%
  filter(Depth > Bathymetric) %>%
  # sample_n(10000) %>%
  ggplot(aes(x = Bathymetric, y = Depth)) +
  geom_point()
```


Make bathymetry complete if necessary

```{r}

```

## Selection of data

Make selection based on:

-   depth of the sample - In case the total depth of the water column is shallower than 100 m, samples are selected from the bottom 20 meters. In deeper waters, samples are selected from the deepest 50 meters.
-   Quality codes less than good (4 and 8) are filtered out
-   Only samples taken in months 7 - 10 are regarded

Convert units of oxygen to mg/l $O_2$. Convert hydrogen sulphide to negative oxygen concentrations in mg/l $O_2$

```{r}

# library("tidylog", warn.conflicts = FALSE) # to log piping process

wk <- stationSamples_with_new_bathymetric %>%  #37690491
  filter(
    Depth <= Bathymetric                               # above sea floor
  ) %>%
  filter(
    Month >= 7 & Month <= 10
  ) %>%
  filter(
    (
      !is.na(Oxygen) & OxygenQ != 4 & OxygenQ != 8        # one of O2 or H2S is not NA
    ) | (
      !is.na(HydrogenSulphide) & HydrogenSulphideQ != 3 & HydrogenSulphideQ != 4
    )
  ) %>%
  filter(
    (case_when(
         Bathymetric < 100 ~ Depth >= Bathymetric - 20,   # max 20 m above sea floor
         Bathymetric >= 100 ~ Depth >= Bathymetric - 50)  # max 50 m above sea floor
    ) 
  ) %>%
  select(
    DataSourceID, 
    SeaRegionID, 
    ClusterID, 
    Latitude, 
    Longitude, 
    Sounding, 
    Bathymetric, 
    Year, 
    Depth, 
    Oxygen, 
    HydrogenSulphide
  ) %>%
  mutate(
    OxygenHydrogenSulphide = ifelse(
      !is.na(Oxygen) & Oxygen != 0, 
      Oxygen / 0.7, # convert ml/l to mg/l
      ifelse(
        !is.na(HydrogenSulphide) | Oxygen == 0, 
        -HydrogenSulphide * 0.022391 / 0.7,  # convert umol/l to ml/l to mg/l 
        NA
      )
    )
  )

```

```{r diffDepthSelection, fig.cap="Distnace from bottom for all selected samples as a function of barymetric. All values should be within 0-20 (up to 50 m depth) or 0-50 (deeper than 50 m)."}
p <- wk %>%
  mutate(diffDepth = Bathymetric - Depth) %>%
  # filter(Depth > Bathymetric) %>%
  sample_n(50000) %>%
  ggplot(aes(x = Bathymetric, y = diffDepth)) +
  geom_point()
ggMarginal(p, type="histogram")
```


### Check locations and status in map

```{r mapStatusSelection, fig.cap="Oxygen concentration status in last 5 years. A sample (n - 5000) is shown for performance reasons. ", eval=FALSE}
qpal <- colorQuantile("YlGn", wk$Oxygen, probs = c(0, 0.05, 0.25, 1))

wk %>%
  filter(Year > 2020) %>%
  sample_n(50000) %>%
  leaflet() %>%
  addTiles() %>%
  addCircleMarkers(
    radius = 4, 
    stroke = F,
    fillOpacity = 1, 
    fillColor = ~qpal(Oxygen)) %>%
  leaflet::addLegend(
    "bottomright", 
    pal = qpal, 
    values = ~Oxygen,
    title = "scale",
    labFormat = labelFormat(),
    opacity = 1
  )

```

## Assign oxygen class

### Make averages for each cluster, location, year and depth

```{r}
wk0 <- wk %>%
  group_by(
    SeaRegionID, 
    ClusterID, 
    Latitude, 
    Longitude, 
    Bathymetric, 
    Year, 
    Depth
  ) %>%
  summarize(
    AvgOxygenHydrogenSulphide = mean(OxygenHydrogenSulphide, na.rm = T),
    .groups = "drop"
  )

```

### Make averages for each cluster, location and year

```{r}
wk1 <- wk0 %>%
  group_by(
    SeaRegionID, 
    ClusterID, 
    Latitude, 
    Longitude, 
    Bathymetric, 
    Year
  ) %>%
  summarize(
    MinDepth = min(Depth),  
    MaxDepth = max(Depth), 
    AvgOxygenHydrogenSulphide = mean(AvgOxygenHydrogenSulphide, na.rm = T),
    .groups = "drop"
  )
```


### Make averages over each cluster and year

These values are used for the status

```{r}
wk2 <- wk1 %>%
  group_by(
    SeaRegionID, 
    ClusterID, 
    Year
  ) %>%
  summarize(
    AvgLatitude = mean(Latitude, na.rm = T), 
    AvgLongitude = mean(Longitude, na.rm = T), 
    MinDepth = min(MinDepth, na.rm = T), 
    MaxDepth = max(MaxDepth, na.rm = T), 
    AvgOxygenHydrogenSulphide = mean(AvgOxygenHydrogenSulphide, na.rm = T)#, 
  )

```

```{r}

prefix = paste0("perc", params$percentile, "_", assessmentYear, "_")

```

### Calculate quartile values

The quartile values are used to assess whether there are 

```{r}
Quartile_all <- wk0 %>%
  group_by(SeaRegionID, ClusterID, Year) %>%
  summarise(
    q = quantile(
      AvgOxygenHydrogenSulphide, 
      probs = as.numeric(params$percentile)/100, 
      na.rm = TRUE
    ),
    median = median(AvgOxygenHydrogenSulphide, na.rm = T),
    n = n(),
    min = min(AvgOxygenHydrogenSulphide, na.rm = T),
    max = max(AvgOxygenHydrogenSulphide, na.rm = T),
    .groups = "drop"
  )

# # # Calculate mean of lower quartile - This is not further used I think (CHECK !!)
# mean_percentile <- wk0 %>% ungroup() %>%
#   left_join(Quartile_all) %>% ungroup() %>%
#   filter(AvgOxygenHydrogenSulphide <= q) %>%
#   group_by(SeaRegionID, ClusterID, Year) %>%
#   summarize(AvgOxygenOrig = mean(AvgOxygenHydrogenSulphide),
#             AvgLatitude = mean(Latitude),
#             AvgLongitude = mean(Longitude),
#             AvgBathymetric = mean(Bathymetric),
#             AvgDepth = mean(Depth),
#             AvgOxygen = unique(q),
#             .groups = 'drop') %>%  # = 5% quantile per year and ClusterID
#   as.data.table()

# hist(mean_percentile$AvgOxygenOrig) # mean of values below percentile
# hist(mean_percentile$AvgOxygen) # percentile values
```

```{r}
fwrite(Quartile_all, file.path("Output", paste0(prefix, "Oxygen_status.csv")))
```



```{r}
# Plot average status for last 5 years 

wk21 <- wk2 %>%
  filter(Year >= assessmentYear - 5 & Year <= assessmentYear) %>%
  group_by(ClusterID) %>%
  summarise(
    Oxygen = mean(AvgOxygenHydrogenSulphide, na.rm = T),
    AvgLongitude = mean(AvgLongitude, na.rm = T),
    AvgLatitude = mean(AvgLatitude, na.rm = T)
  )


plotStatusMaps(bboxEurope, data = wk21, xlong = "AvgLongitude", ylat = "AvgLatitude", 
               parameterValue = "Oxygen", 
               invJet = T, 
               limits = c(0,12))

saveEuropeStatusMap(parameter = paste0(prefix, "Oxygen"))
```
### Trend analysis using Kendall test for each oxygen class

```{r}


classes <- c("O2_4 mg_l", "4_O2_6 mg_l", "O2_6 mg_l")
prettyClassNames <- c("O2 < 4 mg/l", "4 < O2 < 6 mg/l", "O2 > 6 mg/l")

wk22 <- wk2 %>% ungroup() %>%
   mutate(
     class = case_when(
       AvgOxygenHydrogenSulphide < 4 ~ classes[1],
       AvgOxygenHydrogenSulphide >= 4 & AvgOxygenHydrogenSulphide < 6 ~ classes[2],
       AvgOxygenHydrogenSulphide >= 6 ~ classes[3]
     )
   ) 

## possible development: group_by and nest, and run model per clusterID, after which figures are made. 

# maak functie makeOutput(beginyear, endyear, percentile_df = mean_percentile2, outputDir = "output/", prefix = prefix)

make_oxygen_output <- function(
    
    classes = classes, 
    percentile_df = wk22, 
    selected_years,    
    prefix = prefix
    ) {
  
  for(cc in seq(1:length(classes))){
    
    clusterSelection <- percentile_df %>%
      filter(
        Year %in% selected_years,
        class == cc) %>%
      group_by(SeaRegionID, ClusterID, Year, class, AvgLatitude, AvgLongitude) %>%
      summarize(
        NrObsPerClusterYear = n(),
        AvgLatitude = mean(AvgLatitude, na.rm = T), 
        AvgLongitude = mean(AvgLongitude, na.rm = T),
        AvgOxygen = mean(AvgOxygenHydrogenSulphide, na.rm = T)
      ) %>% 
      ungroup() %>%
      group_by(SeaRegionID, ClusterID) %>%
      mutate(NrYears = n()) %>%
      ungroup() %>%
      filter(NrYears >= 5)

    
    # replaced by above. Not sure if part below this worked well
    # clusterSelection <- mean_percentile2[
    #   ClusterID %in% yearcriteria
    # ][,
    #   list(NrClustersPerYear = .N, 
    #        AvgLatitude = mean(AvgLatitude), 
    #        AvgLongitude = mean(AvgLongitude)
    #   ), 
    #   by = .(ClusterID, Year, SeaRegionID)][
    #     , 
    #     .(NrYears = .N), 
    #     by = .(ClusterID, AvgLatitude, AvgLongitude, SeaRegionID)][
    #       NrYears >=5
    #     ]
    # 
    
    try(hist(clusterSelection$NrYears))
    

    if(nrow(clusterSelection != 0)){
      l <- clusterSelection %>% 
        as.data.frame() %>% 
        split(.$ClusterID) 
      
      timeserieslist <- lapply(
        l, 
        function(x) {
          xts::xts(
            x[
              ,"AvgOxygen"
            ], order.by = as.Date(
              as.character(
                x[
                  ,"Year"
                ]
              ),
              format = "%Y"
            )
          )
        }
      )
      
      KendallResult <- lapply(
        timeserieslist, 
        function(x) MannKendall(x)
      )
      
      df.KendallResult <- as.data.frame(
        matrix(
          unlist(
            list.flatten(
              KendallResult
            )
          ), 
          ncol  = 5, 
          byrow = T
        )
      )
      
      names(df.KendallResult) <- c("tau", "sl", "S", "D", "varS")
      df.KendallResult$ClusterID <- as.integer(names(KendallResult))
      KendallResult.clustered <- df.KendallResult %>% 
        left_join(clusterSelection, by = c('ClusterID' = 'ClusterID')) %>%
        filter(!is.na(S)) %>%
        mutate(trend = case_when(
          .$sl <= 0.05 & .$S < 0 ~ "decreasing",
          .$sl <= 0.05 & .$S > 0 ~ "increasing",
          .$sl > 0.05 ~ "no trend")
        ) %>%
        mutate(trend = as.factor(trend)) %>%
        mutate(mutate(across(where(is.numeric), \(x) round(x, 3))))
      
      KendallResult.clustered$trend <- factor(KendallResult.clustered$trend, levels =  c("no trend", "decreasing", "increasing"))
      
      fwrite(KendallResult.clustered, paste0("output/", prefix, "trend_dissolvedoxygen", classes[cc], ".csv"))
      
      plotKendallClasses(
        plotdata = KendallResult.clustered, 
        parameterValue = paste(prefix, "Oxygen", classes[cc])
      )
      saveEuropeTrendMap(paste(prefix, "Oxygen", classes[cc]))
    }
  }

}

# make products for current situation (-15 years until now)
# 
make_oxygen_output(
  percentile_df = wk22,
  classes = classes,
  selected_years = c((assessmentYear - 15): assessmentYear), 
  prefix = paste0("perc", params$percentile, "_", assessmentYear, "_")
)

# make products for before 2000 situation

make_oxygen_output(
  percentile_df = wk22,
  classes = classes,
  selected_years = c(1980: 1999), 
  prefix = paste0("perc", params$percentile, "_", 1980, "-", 1999, "_")
)

# make products for after 2000 situation

make_oxygen_output(
  percentile_df = wk22,
  classes = classes,
  selected_years = c(2000: assessmentYear), 
  prefix = paste0("perc", params$percentile, "_", 2000, "-", assessmentYear, "_")
)

```


```{r}
source("make_bar_graphs_per_region.R")
```

